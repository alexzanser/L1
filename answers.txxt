1. Когда известна длина копируемой строки - copy(), в общем случае - string.Builder.WriteString().
2. Интерфейсный тип это набор методов.  Любой тип, который реализует перечисленные методы может быть использован от имени интерфейса.
Использование интерфейсовпозволяет абстрагироваться от конкретных реализаций ,
а опираться на абстракции, которые удвлетворяют заданным требованиям(методам).

3.RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. Например, стандартный тип map.
Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, пока вы не отпустите мьютекс через .Unlock().
Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других горутинах блокируются, вызовы .RLock() спокойно проходят. Когда отпускаете мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди могут забирать мьютекс на себя.
Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность. 

4. Буферизованный каналы могут хранить в очереди поступающие собщения, благодаря этому горутина, отправляющая блокируется не сразу, 
а только когда буфер заполнен.

5. 0 байт

6.нет

7. в порядке возрастания
8. New - выделяет динамическую память, инициализирует эту память, возвращает на нее указатель, работает для всех типов.
   Make - выделяет динамическую память, возвращает объект, работает для map, slice, chan.

9. make, var, :=
10. 1, потому что внутри функции мы изменили локальное значение указателя, однако, внутри main указатель сохранил то же значение, ссылается в то же место
11. 